# a
a
'a'
"a"
"#{a}"
"#{a ; b}"
"\""
%{a}
%Q{a}
%q{a}
%w( a b c )
:a
1
1_0
1.0
0x1
[1]
{:a => 2}
{a: 2}
/a/
/#{a}/
/#{a ; b}/
/a/imx
/[a]/
/^a$/
/\Aa\Z/
/[^a]/
/(a|b)/
/a{1,2}/
/(?:a)/
%r{a}
# todo: lookaround
a = 1
a, b = 1, 2
a, b, c = 1, 2, 3
a, b = *c
*a = b, c
a == b
a != b
a === b
a =~ b
a !~ b
!a
+1
-1
a || b
a && b
a | b
a & b
a or b
a and b
not a
a ^ b
a ** b
a * b
a + b
a - b
a % b
a / b
$a
@a
@@a
a.b
a(b)
Const
?a
a ? b : c
(a + b)
a[b]
a << b
a >> b
a > b
a < b
a >= b
a <= b
a ; b
`a`
`#{a}`
`\n`
if a ; 1 ; elsif b ; 2; else 3 ; end
case a ; when b ; 1 ; when c ; 2 ; else ; 3 ; end
a(b)
a(b, c, d)
a(b, c => c, e => f)
a(*b)
a(&b)
a.b
a.b(c)
a.b.c.d
a.b(c).d(e)
a.b {|c| d }
a.b {|*c| d }
a.b do |c| ; d ; end
do ; a ; while b # FIXME: not valid Ruby?
->(a){ b }
while a ; b ; end
while a ; b ; break ; end
while a ; b ; continue ; end
for a in b ; c ; end
begin ; a ; rescue b => c ; d ; else ; e ; ensure ; f ; end
def a ; end
def z(y, m = n, *o, &p) ; 1 ; end
def a ; z ; rescue b => w ; x ; else c ; y ; ensure ; d ; end
def self.quux ; end
def a=(b) ; end
def [](a) ; end
def <<(a) ; end
alias a b
alias :a, :b
class << self ; end
self
super
super(a)
Foo.new
Foo.new(a)
Foo::Bar::Baz
class Foo < Bar ; end
class Foo::Bar ; end
class Foo::Bar::Baz < Quux ; end
module Foo ; end
module Foo::Bar ; end
module Foo::Bar::Baz ; end
class Foo ; rescue a => b ; end
module Foo ; rescue a => b ; end
FOO
Foo::BAR
Foo::Bar::BAZ
FOO[a]
FOO = 1
true
false
nil
require 'foo'
load 'foo.rb'
# TODO: all those other reserved words
# TODO: heredoc
